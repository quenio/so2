Index: include/machine/pc/ic.h
===================================================================
--- include/machine/pc/ic.h	(revision 3782)
+++ include/machine/pc/ic.h	(working copy)
@@ -171,59 +171,59 @@
     enum {
         LOCAL_APIC_PHY_ADDR	= 0xfee00000,
         LOCAL_APIC_LOG_ADDR	= Memory_Map<PC>::APIC,
-        LOCAL_APIC_SIZE         = Memory_Map<PC>::VGA - Memory_Map<PC>::APIC,
-        IO_APIC_PHY_ADDR	= 0xfec00000
+        LOCAL_APIC_SIZE     = Memory_Map<PC>::VGA - Memory_Map<PC>::APIC,
+        IO_APIC_PHY_ADD     = 0xfec00000
     };
 
     // Memory-mapped registers
     enum {
-        ID =			0x020,	// Task priority 
-        VERSION =		0x030,	// Task priority 
-        TPR =			0x080,	// Task priority 
-        APR =			0x090,	// Arbitration priority 
-        PPR =			0x0a0,	// Processor priority 
-        EOI =			0x0b0,	// End of interrupt 
-        RRR =			0x0c0,	// Remote read 
-        LDR =			0x0d0,	// Logical destination 
-        DFR =			0x0e0,	// Destination format 
-        SVR =			0x0f0,	// Spurious interrupt vector 
-        ISR0_32 =		0x100,	// In-service 
-        ISR32_63 =		0x110,	// In-service 
-        ISR64_95 =		0x120,	// In-service 
-        ISR96_127 =		0x130,	// In-service 
-        ISR128_159 =		0x140,	// In-service 
-        ISR160_191 =		0x150,	// In-service 
-        ISR192_223 =		0x160,	// In-service 
-        ISR224_255 =		0x170,	// In-service 
-        TMR0_32 =		0x180,	// Trigger mode 
-        TMR32_63 =		0x190,	// Trigger mode 
-        TMR64_95 =		0x1a0,	// Trigger mode 
-        TMR96_127 =		0x1b0,	// Trigger mode 
-        TMR128_159 =		0x1c0,	// Trigger mode 
-        TMR160_191 =		0x1d0,	// Trigger mode 
-        TMR192_223 =		0x1e0,	// Trigger mode 
-        TMR224_255 =		0x1f0,	// Trigger mode 
-        IRR0_32 =		0x200,	// Interrupt request 
-        IRR32_63 =		0x210,	// Interrupt request 
-        IRR64_95 =		0x220,	// Interrupt request 
-        IRR96_127 =		0x230,	// Interrupt request 
-        IRR128_159 =		0x240,	// Interrupt request 
-        IRR160_191 =		0x250,	// Interrupt request 
-        IRR192_223 =		0x260,	// Interrupt request 
-        IRR224_255 =		0x270,	// Interrupt request 
-        ESR =			0x280,	// Error status 
-        LVT_CMCI =		0x2f0,	// LVT CMCI 
-        ICR0_31 =		0x300,	// Interrupt command 
-        ICR32_63 =		0x310,	// Interrupt command 
-        LVT_TIMER =		0x320,	// LVT timer 
-        LVT_THERMAL =		0x330,	// LVT thermal sensor 
-        LVT_PERF =		0x340,	// LVT performance monitor 
-        LVT_LINT0 =		0x350,	// LVT interrupt line 0 
-        LVT_LINT1 =		0x360,	// LVT interrupt line 1 
-        LVT_ERROR =		0x370,	// LVT error 
-        TIMER_INITIAL =		0x380,	// Timer's initial count 
-        TIMER_CURRENT =		0x390,	// Timer's current count 
-        TIMER_PRESCALE =	0x3e0	// Timer's BUS CLOCK prescaler 
+        ID =			0x020,	// Task priority
+        VERSION =		0x030,	// Task priority
+        TPR =			0x080,	// Task priority
+        APR =			0x090,	// Arbitration priority
+        PPR =			0x0a0,	// Processor priority
+        EOI =			0x0b0,	// End of interrupt
+        RRR =			0x0c0,	// Remote read
+        LDR =			0x0d0,	// Logical destination
+        DFR =			0x0e0,	// Destination format
+        SVR =			0x0f0,	// Spurious interrupt vector
+        ISR0_32 =		0x100,	// In-service
+        ISR32_63 =		0x110,	// In-service
+        ISR64_95 =		0x120,	// In-service
+        ISR96_127 =		0x130,	// In-service
+        ISR128_159 =		0x140,	// In-service
+        ISR160_191 =		0x150,	// In-service
+        ISR192_223 =		0x160,	// In-service
+        ISR224_255 =		0x170,	// In-service
+        TMR0_32 =		0x180,	// Trigger mode
+        TMR32_63 =		0x190,	// Trigger mode
+        TMR64_95 =		0x1a0,	// Trigger mode
+        TMR96_127 =		0x1b0,	// Trigger mode
+        TMR128_159 =		0x1c0,	// Trigger mode
+        TMR160_191 =		0x1d0,	// Trigger mode
+        TMR192_223 =		0x1e0,	// Trigger mode
+        TMR224_255 =		0x1f0,	// Trigger mode
+        IRR0_32 =		0x200,	// Interrupt request
+        IRR32_63 =		0x210,	// Interrupt request
+        IRR64_95 =		0x220,	// Interrupt request
+        IRR96_127 =		0x230,	// Interrupt request
+        IRR128_159 =		0x240,	// Interrupt request
+        IRR160_191 =		0x250,	// Interrupt request
+        IRR192_223 =		0x260,	// Interrupt request
+        IRR224_255 =		0x270,	// Interrupt request
+        ESR =			0x280,	// Error status
+        LVT_CMCI =		0x2f0,	// LVT CMCI
+        ICR0_31 =		0x300,	// Interrupt command
+        ICR32_63 =		0x310,	// Interrupt command
+        LVT_TIMER =		0x320,	// LVT timer
+        LVT_THERMAL =		0x330,	// LVT thermal sensor
+        LVT_PERF =		0x340,	// LVT performance monitor
+        LVT_LINT0 =		0x350,	// LVT interrupt line 0
+        LVT_LINT1 =		0x360,	// LVT interrupt line 1
+        LVT_ERROR =		0x370,	// LVT error
+        TIMER_INITIAL =		0x380,	// Timer's initial count
+        TIMER_CURRENT =		0x390,	// Timer's current count
+        TIMER_PRESCALE =	0x3e0	// Timer's BUS CLOCK prescaler
     };
 
     // Flags
@@ -339,7 +339,7 @@
 
     static void reset(Log_Addr addr = LOCAL_APIC_LOG_ADDR) {
         // APIC must be on very early in the boot process, so it is
-        // subject to memory remappings. We also cannot be sure about 
+        // subject to memory remappings. We also cannot be sure about
         // global constructors here
         remap(addr);
         if(Traits<System>::multicore) {
@@ -365,10 +365,10 @@
         write(LVT_TIMER, v);
     }
 
-    static void enable_timer() { 
+    static void enable_timer() {
         write(LVT_TIMER, read(LVT_TIMER) & ~TIMER_MASKED);
     }
-    static void disable_timer() { 
+    static void disable_timer() {
         write(LVT_TIMER, read(LVT_TIMER) | TIMER_MASKED);
     }
 
@@ -375,7 +375,7 @@
     static Reg32 read_timer() {
         return read(TIMER_CURRENT);
     }
-    
+
     static void reset_timer() {
         disable();
         write(TIMER_CURRENT, read(TIMER_INITIAL));
Index: include/machine/pc/info.h
===================================================================
--- include/machine/pc/info.h	(revision 3782)
+++ include/machine/pc/info.h	(working copy)
@@ -43,8 +43,8 @@
         PAddr mem_top;          // Memory top address
         PAddr io_base;          // I/O Memory base address
         PAddr io_top;           // I/O Memory top address
- 	PAddr ext_base;         // Boot Image EXTRA segment base address
- 	PAddr ext_top;          // Boot Image EXTRA segment top address
+ 	      PAddr ext_base;         // Boot Image EXTRA segment base address
+ 	      PAddr ext_top;          // Boot Image EXTRA segment top address
         PAddr idt;              // IDT
         PAddr gdt;              // GDT
         PAddr tss0;             // TSS0 (only for system call)
@@ -110,7 +110,7 @@
         unsigned int cpu_clock;
         unsigned int bus_clock;
     };
-        
+
 public:
     friend Debug & operator<<(Debug & db, const System_Info<PC> & si);
 
Index: include/scheduler.h
===================================================================
--- include/scheduler.h	(revision 3782)
+++ include/scheduler.h	(working copy)
@@ -76,9 +76,7 @@
     public:
         FCFS(int p = NORMAL); // Defined at Alarm
     };
-}
 
-
 // Scheduling_Queue
 template<typename T, typename R = typename T::Criterion>
 class Scheduling_Queue: public Scheduling_List<T> {};
Index: include/system/config.h
===================================================================
--- include/system/config.h	(revision 3782)
+++ include/system/config.h	(working copy)
@@ -7,15 +7,15 @@
 // ARCHITECTURE, MACHINE, AND APPLICATION SELECTION
 // This section is generated automatically from makedefs by $EPOS/etc/makefile
 //============================================================================
-#define MODE xxx
-#define ARCH xxx
-#define MACH xxx
-#define MMOD xxx
-#define APPL xxx
-#define __mode_xxx__
-#define __arch_xxx__
-#define __mach_xxx__
-#define __mmod_xxx__
+#define MODE library
+#define ARCH ia32
+#define MACH pc
+#define MMOD legacy
+#define APPL delay_test
+#define __mode_library__
+#define __arch_ia32__
+#define __mach_pc__
+#define __mmod_legacy__
 
 #if defined (__arch_avr__) || defined (__mmod_lm3s811__)
 #define __no_networking__
Index: include/system/traits.h
===================================================================
--- include/system/traits.h	(revision 3782)
+++ include/system/traits.h	(working copy)
@@ -28,7 +28,7 @@
     enum {Legacy};
     static const unsigned int MODEL = Legacy;
 
-    static const unsigned int CPUS = 1;
+    static const unsigned int CPUS = 8;
     static const unsigned int NODES = 1; // > 1 => NETWORKING
 };
 
Index: include/thread.h
===================================================================
--- include/thread.h	(revision 3782)
+++ include/thread.h	(working copy)
@@ -101,6 +101,8 @@
 
     Criterion & criterion() { return const_cast<Criterion &>(_link.rank()); }
 
+    // TODO Implementar lock()/unlock() usando Spin.
+    // TODO Depois da modificação, verificar usos de lock() / unlock() fora de Thread. Precisam de Spin?
     static void lock() { CPU::int_disable(); }
     static void unlock() { CPU::int_enable(); }
     static bool locked() { return CPU::int_disabled(); }
Index: include/utility/heap.h
===================================================================
--- include/utility/heap.h	(revision 3782)
+++ include/utility/heap.h	(working copy)
@@ -123,26 +123,27 @@
     }
 
     void * alloc(unsigned int bytes) {
-	enter();
-	void * tmp = T::alloc(bytes);
-	leave();
-	return tmp;
+        enter();
+        void * tmp = T::alloc(bytes);
+        leave();
+        return tmp;
     }
 
     void free(void * ptr) {
-	enter();
-	T::free(ptr);
-	leave();
+        enter();
+        T::free(ptr);
+        leave();
     }
 
     void free(void * ptr, unsigned int bytes) {
-	enter();
-	T::free(ptr, bytes);
-	leave();
+        enter();
+        T::free(ptr, bytes);
+        leave();
     }
 
 private:
     void enter() {
+        // WARNING: Se houver algum deadlock, verificar se não é porque acquire() está antes de int_disable()
         _lock.acquire();
         CPU::int_disable();
     }
@@ -156,7 +157,6 @@
     Spin _lock;
 };
 
-
 // Heap
 class Heap: public Heap_Wrapper<Simple_Heap, Traits<System>::multicore>
 {
Index: include/utility/list.h
===================================================================
--- include/utility/list.h	(revision 3782)
+++ include/utility/list.h	(working copy)
@@ -35,7 +35,7 @@
 
     public:
         Pointer(const T * o): _object(o) {}
-    
+
         T * object() const { return const_cast<T *>(_object); }
 
     private:
@@ -77,12 +77,12 @@
 
     public:
         Singly_Linked(const T * o): _object(o), _next(0) {}
-    
+
         T * object() const { return const_cast<T *>(_object); }
 
         Element * next() const { return _next; }
         void next(Element * e) { _next = e; }
-    
+
     private:
         const T * _object;
         Element * _next;
@@ -100,7 +100,7 @@
 
     public:
         Singly_Linked_Ordered(const T * o, const R & r = 0): _object(o), _rank(r), _next(0) {}
-    
+
         T * object() const { return const_cast<T *>(_object); }
 
         Element * next() const { return _next; }
@@ -138,7 +138,7 @@
         void size(unsigned int l) { _size = l; }
         void shrink(unsigned int n) { _size -= n; }
         void expand(unsigned int n) { _size += n; }
-    
+
     private:
         const T * _object;
         unsigned int _size;
@@ -155,7 +155,7 @@
 
     public:
         Doubly_Linked(const T * o): _object(o), _prev(0), _next(0) {}
-    
+
         T * object() const { return const_cast<T *>(_object); }
 
         Element * prev() const { return _prev; }
@@ -162,7 +162,7 @@
         Element * next() const { return _next; }
         void prev(Element * e) { _prev = e; }
         void next(Element * e) { _next = e; }
-    
+
     private:
         const T * _object;
         Element * _prev;
@@ -180,7 +180,7 @@
 
     public:
         Doubly_Linked_Ordered(const T * o,  const R & r = 0): _object(o), _rank(r), _prev(0), _next(0) {}
-    
+
         T * object() const { return const_cast<T *>(_object); }
 
         Element * prev() const { return _prev; }
@@ -199,7 +199,7 @@
         Element * _prev;
         Element * _next;
     };
-    
+
     // Scheduling List Element
     template<typename T, typename R = Rank>
     class Doubly_Linked_Scheduling
@@ -211,7 +211,7 @@
 
     public:
         Doubly_Linked_Scheduling(const T * o,  const R & r = 0): _object(o), _rank(r), _prev(0), _next(0) {}
-    
+
         T * object() const { return const_cast<T *>(_object); }
 
         Element * prev() const { return _prev; }
@@ -254,7 +254,7 @@
         void size(unsigned int l) { _size = l; }
         void shrink(unsigned int n) { _size -= n; }
         void expand(unsigned int n) { _size += n; }
-    
+
     private:
         const T * _object;
         unsigned int _size;
@@ -320,7 +320,7 @@
 
         Iterator & operator--() { _current = _current->prev(); return *this; }
         Iterator operator--(int) { Iterator tmp = *this; --*this; return tmp; }
-        
+
         bool operator==(const Iterator & i) const { return _current == i._current; }
         bool operator!=(const Iterator & i) const { return _current != i._current; }
 
@@ -372,7 +372,7 @@
             _size++;
         }
     }
-    
+
     Element * remove() { return remove_head(); }
 
     Element * remove(Element * e) {
@@ -416,13 +416,13 @@
             return remove(e);
         return 0;
     }
-    
+
     Element * search(const Object_Type * obj) {
         Element * e = _head;
             for(; e && (e->object() != obj); e = e->next());
             return e;
     }
-    
+
 protected:
     bool last() const { return (_size == 1); }
 
@@ -455,8 +455,8 @@
 
 
 // Singly-Linked, Ordered List
-template<typename T, 
-          typename R = List_Element_Rank, 
+template<typename T,
+          typename R = List_Element_Rank,
           typename El = List_Elements::Singly_Linked_Ordered<T, R>,
           bool relative = false>
 class Simple_Ordered_List: public Simple_List<T, El>
@@ -477,7 +477,7 @@
     using Base::begin;
     using Base::end;
     using Base::remove_head;
-    
+
     void insert(Element * e) {
         if(empty())
             insert_first(e);
@@ -503,7 +503,7 @@
             }
         }
     }
-    
+
     Element * remove() { return remove_head(); }
 
     Element * remove(Element * e) {
@@ -519,7 +519,7 @@
             return remove(e);
         return 0;
     }
-    
+
     Element * search_rank(const Rank_Type & rank) {
         Element * e = head();
         for(; e && (e->rank() != rank); e = e->next());
@@ -536,7 +536,7 @@
 
 
 // Singly-Linked, Relative Ordered List
-template<typename T, 
+template<typename T,
           typename R = List_Element_Rank,
           typename El = List_Elements::Singly_Linked_Ordered<T, R> >
 class Simple_Relative_List: public Simple_Ordered_List<T, R, El, true> {};
@@ -572,13 +572,13 @@
         for(; e && (e->size() < s); e = e->next());
         return e;
     }
-    
+
     Element * search_left(const Object_Type * obj) {
         Element * e = head();
         for(; e && (e->object() + e->size() != obj); e = e->next());
         return e;
     }
-    
+
     void insert_merging(Element * e, Element ** m1, Element ** m2) {
         _grouped_size += e->size();
         *m1 = *m2 = 0;
@@ -595,7 +595,7 @@
         } else
             insert_tail(e);
     }
-    
+
     Element * search_decrementing(unsigned int s) {
         Element * e = search_size(s);
         if(e) {
@@ -606,7 +606,7 @@
         }
         return e;
     }
-    
+
 private:
     unsigned int _grouped_size;
 };
@@ -627,10 +627,10 @@
 
     bool empty() const { return (_size == 0); }
     unsigned int size() const { return _size; }
-    
+
     Element * head() { return _head; }
     Element * tail() { return _tail; }
-    
+
     Iterator begin() { return Iterator(_head); }
     Iterator end() { return Iterator(0); }
 
@@ -637,7 +637,7 @@
     void insert(Element * e) { insert_tail(e); }
 
     void insert_head(Element * e) {
-        db<Lists>(TRC) << "List::insert_head(e=" << e 
+        db<Lists>(TRC) << "List::insert_head(e=" << e
                        << ") => {p=" << (e ? e->prev() : (void *) -1)
                        << ",o=" << (e ? e->object() : (void *) -1)
                        << ",n=" << (e ? e->next() : (void *) -1)
@@ -661,7 +661,7 @@
     }
 
     void insert_tail(Element * e) {
-        db<Lists>(TRC) << "List::insert_tail(e=" << e 
+        db<Lists>(TRC) << "List::insert_tail(e=" << e
                        << ") => {p=" << (e ? e->prev() : (void *) -1)
                        << ",o=" << (e ? e->object() : (void *) -1)
                        << ",n=" << (e ? e->next() : (void *) -1)
@@ -683,11 +683,11 @@
         print_head();
         print_tail();
     }
-    
+
     Element * remove() { return remove_head(); }
 
     Element * remove(Element * e) {
-        db<Lists>(TRC) << "List::remove(e=" << e 
+        db<Lists>(TRC) << "List::remove(e=" << e
                        << ") => {p=" << (e ? e->prev() : (void *) -1)
                        << ",o=" << (e ? e->object() : (void *) -1)
                        << ",n=" << (e ? e->next() : (void *) -1)
@@ -762,13 +762,13 @@
             return remove(e);
         return 0;
     }
-    
+
     Element * search(const Object_Type * obj) {
         Element * e = _head;
         for(; e && (e->object() != obj); e = e->next());
         return e;
     }
-    
+
 protected:
     bool last() const { return (_size == 1); }
 
@@ -799,7 +799,7 @@
     }
 
     void insert_first(Element * e) {
-        db<Lists>(TRC) << "List::insert_first(e=" << e 
+        db<Lists>(TRC) << "List::insert_first(e=" << e
                        << ") => {p=" << (e ? e->prev() : (void *) -1)
                        << ",o=" << (e ? e->object() : (void *) -1)
                        << ",n=" << (e ? e->next() : (void *) -1)
@@ -836,7 +836,7 @@
     }
 
     void print_head() {
-        db<Lists>(INF) << "List[" << this << "]::head=" << head() 
+        db<Lists>(INF) << "List[" << this << "]::head=" << head()
                        << " => {p=" << (head() ? head()->prev() : (void *) -1)
                        << ",o=" << (head() ? head()->object() : (void *) -1)
                        << ",n=" << (head() ? head()->next() : (void *) -1)
@@ -844,7 +844,7 @@
     }
 
     void print_tail() {
-        db<Lists>(INF) << "List[" << this << "]::tail=" << tail() 
+        db<Lists>(INF) << "List[" << this << "]::tail=" << tail()
                        << " => {p=" << (tail() ? tail()->prev() : (void *) -1)
                        << ",o=" << (tail() ? tail()->object() : (void *) -1)
                        << ",n=" << (tail() ? tail()->next() : (void *) -1)
@@ -887,7 +887,7 @@
     using Base::search;
 
     void insert(Element * e) {
-        db<Lists>(TRC) << "Ordered_List::insert(e=" << e 
+        db<Lists>(TRC) << "Ordered_List::insert(e=" << e
                        << ") => {p=" << (e ? e->prev() : (void *) -1)
                        << ",o=" << (e ? e->object() : (void *) -1)
                        << ",n=" << (e ? e->next() : (void *) -1)
@@ -917,8 +917,8 @@
             }
         }
     }
-    
-    Element * remove() { 
+
+    Element * remove() {
         db<Lists>(TRC) << "Ordered_List::remove()" << endl;
 
         return Base::remove_head();
@@ -925,7 +925,7 @@
     }
 
     Element * remove(Element * e) {
-        db<Lists>(TRC) << "Ordered_List::remove(e=" << e 
+        db<Lists>(TRC) << "Ordered_List::remove(e=" << e
                        << ") => {p=" << (e ? e->prev() : (void *) -1)
                        << ",o=" << (e ? e->object() : (void *) -1)
                        << ",n=" << (e ? e->next() : (void *) -1)
@@ -947,7 +947,7 @@
         else
             return 0;
     }
-    
+
     Element * search_rank(const Rank_Type & rank) {
         Element * e = head();
         for(; e && (e->rank() != rank); e = e->next());
@@ -1247,7 +1247,7 @@
 };
 
 // Doubly-Linked, Grouping List
-template<typename T, 
+template<typename T,
           typename El = List_Elements::Doubly_Linked_Grouping<T> >
 class Grouping_List: public List<T, El>
 {
@@ -1275,19 +1275,19 @@
     using Base::print_tail;
 
     unsigned int grouped_size() const { return _grouped_size; }
-    
+
     Element * search_size(unsigned int s) {
         Element * e = head();
         for(; e && (e->size() < sizeof(Element) + s) && (e->size() != s); e = e->next());
         return e;
     }
-    
+
     Element * search_left(const Object_Type * obj) {
         Element * e = head();
         for(; e && (e->object() + e->size() != obj); e = e->next());
         return e;
     }
-    
+
     void insert_merging(Element * e, Element ** m1, Element ** m2) {
         db<Lists>(TRC) << "Grouping_List::insert_merging(e=" << e << ")" << endl;
 
@@ -1308,7 +1308,7 @@
             *m2 = e;
         }
     }
-    
+
     Element * search_decrementing(unsigned int s) {
         db<Lists>(TRC) << "Grouping_List::search_decrementing(s=" << s << ")" << endl;
         print_head();
@@ -1324,11 +1324,11 @@
 
         return e;
     }
-    
+
 private:
     unsigned int _grouped_size;
 };
 
 __END_UTIL
- 
+
 #endif
Index: include/utility/ostream.h
===================================================================
--- include/utility/ostream.h	(revision 3782)
+++ include/utility/ostream.h	(working copy)
@@ -28,7 +28,7 @@
             preamble();
         return *this;
     }
-    
+
     OStream & operator<<(const Endl & endl) {
         if(Traits<System>::multicore)
             trailler();
@@ -67,7 +67,7 @@
         print(buf);
         return *this;
     }
-    OStream & operator<<(unsigned char c) { 
+    OStream & operator<<(unsigned char c) {
         return operator<<(static_cast<unsigned int>(c));
     }
 
@@ -90,7 +90,7 @@
         print(buf);
         return *this;
     }
-    OStream & operator<<(unsigned short s) { 
+    OStream & operator<<(unsigned short s) {
         return operator<<(static_cast<unsigned int>(s));
     }
     OStream & operator<<(unsigned long l) {
@@ -118,9 +118,9 @@
         return *this;
     }
 
-    OStream & operator<<(const char * s) { 
+    OStream & operator<<(const char * s) {
         print(s);
-        return *this; 
+        return *this;
     }
 
     OStream & operator<<(float f) {
@@ -179,11 +179,11 @@
 
 private:
     int _base;
+    volatile bool _error;
     volatile int _lock;
-    volatile bool _error;
 
     static const char _digits[];
-}; 
+};
 
 extern OStream::Begl begl;
 extern OStream::Endl endl;
Index: src/abstraction/thread.cc
===================================================================
--- src/abstraction/thread.cc	(revision 3782)
+++ src/abstraction/thread.cc	(working copy)
@@ -17,6 +17,7 @@
 Scheduler_Timer * Thread::_timer;
 Scheduler<Thread> Thread::_scheduler;
 
+
 // Methods
 void Thread::constructor_prolog(unsigned int stack_size)
 {
Index: src/init/init_first.cc
===================================================================
--- src/init/init_first.cc	(revision 3782)
+++ src/init/init_first.cc	(working copy)
@@ -26,33 +26,23 @@
             return;
         }
 
-        db<Init>(INF) << "Initializing the first thread: " << endl;
-
         Thread * first;
-        if(Machine::cpu_id() == 0) {
-            // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
-            // which will directly call main(). In this case, _init will have already been called,
-            // before Init_Application, to construct main()'s global objects.
-            first = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(__epos_app_entry));
+        if (Machine::cpu_id() == 0) {
+          // If EPOS is not a kernel, then adjust the application entry point to __epos_app_entry,
+          // which will directly call main(). In this case, _init will have already been called,
+          // before Init_Application, to construct main()'s global objects.
+          first = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(__epos_app_entry));
 
-            // Idle thread creation must succeed main, thus avoiding implicit rescheduling.
-            new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
-        } else
-            first = new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
+          // Idle thread creation must succeed main, thus avoiding implicit rescheduling
+          new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
+        } else {
+          first = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::IDLE), &Thread::idle);
+        }
 
-        Machine::smp_barrier();
+        // db<Init, Thread>(WRN) << "Dispatching the first thread: " << first << " on CPU: " << Machine::cpu_id() << " of " << Machine::n_cpus() << endl;
 
-        db<Init>(INF) << "done!" << endl;
-
-        db<Init>(INF) << "INIT ends here!" << endl;
-
-        db<Init, Thread>(INF) << "Dispatching the first thread: " << first << endl;
-
         This_Thread::not_booting();
 
-        // This barrier is particularly important, since afterwards the temporary stacks
-        // and data structures established by SETUP and announced as "free memory" will indeed be
-        // available to user threads
         Machine::smp_barrier();
 
         first->_context->load();
@@ -60,7 +50,7 @@
 };
 
 // Global object "init_first" must be constructed last in the context of the
-// OS, for it activates the first application thread (usually main()) 
+// OS, for it activates the first application thread (usually main())
 Init_First init_first;
 
 __END_SYS
Index: src/init/init_system.cc
===================================================================
--- src/init/init_system.cc	(revision 3782)
+++ src/init/init_system.cc	(working copy)
@@ -22,7 +22,7 @@
         // Only the boot CPU runs INIT_SYSTEM fully
         if(Machine::cpu_id() != 0) {
             // Wait until the boot CPU has initialized the machine
-            Machine::smp_barrier();
+            Machine::smp_barrier(); // WARNING: Se não estiver funcionando, verificar se ncpus está realmente inicializado.
             // For IA-32, timer is CPU-local. What about other SMPs?
             Timer::init();
             Machine::smp_barrier();
@@ -67,6 +67,7 @@
         }
 
         // Initialization continues at init_first
+        Machine::smp_barrier(si->bm.n_cpus);
     }
 };
 
Index: src/setup/pc_setup.cc
===================================================================
--- src/setup/pc_setup.cc	(revision 3782)
+++ src/setup/pc_setup.cc	(working copy)
@@ -59,7 +59,7 @@
 // PC_Setup is responsible for bringing the machine into a usable state. It
 // sets up several IA32 data structures (IDT, GDT, etc), builds a basic
 // memory model (flat) and a basic thread model (exclusive task/exclusive
-// thread). 
+// thread).
 //------------------------------------------------------------------------
 class PC_Setup
 {
@@ -178,7 +178,7 @@
         setup_sys_pt();
         setup_sys_pd();
 
-        // Enable paging 
+        // Enable paging
         // We won't be able to print anything before the remap() bellow
         db<Setup>(INF) << "IP=" << CPU::ip() << endl;
         db<Setup>(INF) << "SP=" << reinterpret_cast<void *>(CPU::sp()) << endl;
@@ -207,7 +207,7 @@
         // Wait for the Boot CPU to setup page tables
         while(!Paging_Ready);
 
-        // Enable paging 
+        // Enable paging
         enable_paging();
     }
 
@@ -406,7 +406,7 @@
     // System Page Table (1 x sizeof(Page))
     top_page -= 1;
     si->pmm.sys_pt = top_page * sizeof(Page);
-    
+
     // System Page Directory (1 x sizeof(Page))
     top_page -= 1;
     si->pmm.sys_pd = top_page * sizeof(Page);
@@ -470,7 +470,7 @@
     } else {
         si->pmm.ext_base = 0;
         si->pmm.ext_top = 0;
-    }	
+    }
 }
 
 //========================================================================
@@ -526,6 +526,7 @@
         kout << "  APP code:     " << si->lm.app_code_size << " bytes"
              << "\tdata: " << si->lm.app_data_size << " bytes" << endl;
     }
+    kout << "  CPU count:    " << si->bm.n_cpus << endl;
     if(si->lm.has_ext) {
         kout << "  Extras:       " << si->lm.app_extra_size << " bytes" << endl;
     }
@@ -539,7 +540,7 @@
 }
 
 //========================================================================
-void PC_Setup::enable_paging() 
+void PC_Setup::enable_paging()
 {
     // Set IDTR (limit = 1 x sizeof(Page))
     CPU::idtr(sizeof(Page) - 1, IDT);
@@ -635,7 +636,7 @@
         	   << ",pt="   << (void *)si->pmm.sys_pt
         	   << ",pd="   << (void *)si->pmm.sys_pd
         	   << ",info=" << (void *)si->pmm.sys_info
-        	   << ",tss0=" << Phy_Addr(si->pmm.tss0) 
+        	   << ",tss0=" << Phy_Addr(si->pmm.tss0)
         	   << ",mem="  << (void *)si->pmm.phy_mem_pts
         	   << ",io="   << (void *)si->pmm.io_pts
         	   << ",sysc=" << (void *)si->pmm.sys_code
@@ -1008,10 +1009,10 @@
 extern "C" { void setup(char * bi); }
 
 //========================================================================
-// _start		  
+// _start
 //
-// "_start" MUST BE PC_SETUP's first function, since PC_BOOT assumes 
-// offset "0" to be the entry point. It is a kind of bridge between the 
+// "_start" MUST BE PC_SETUP's first function, since PC_BOOT assumes
+// offset "0" to be the entry point. It is a kind of bridge between the
 // assembly world of PC_BOOT and the C++ world of PC_SETUP. It's main
 // tasks are:
 //
@@ -1054,7 +1055,7 @@
 
         // Broadcast INIT IPI to all APs excluding self
         APIC::ipi_init(si->bm.cpu_status);
-        
+
         // Broadcast STARTUP IPI to all APs excluding self
         // Non-boot CPUs will run a simplified boot strap just to
         // trampoline them into protected mode
@@ -1079,7 +1080,7 @@
 
         // Load SETUP considering the address in the ELF header
         // Be careful: by reloading SETUP, global variables have been reset to
-        // the values stored in the ELF data segment 
+        // the values stored in the ELF data segment
         // Also check if this wouldn't destroy the boot image
         char * addr = reinterpret_cast<char *>(elf->segment_address(0));
         int size = elf->segment_size(0);
@@ -1099,7 +1100,7 @@
         // Passes a pointer to the just allocated stack pool to other CPUs
         Stacks = dst;
         Stacks_Ready = true;
-        
+
     } else { // Additional CPUs (APs)
 
         // Inform BSP that this AP has been initialized
@@ -1135,7 +1136,7 @@
 
     // Pass the boot image to SETUP
     ASM("pushl %0" : : "r" (Stacks));
-    
+
     // Call setup()
     // the assembly is necessary because the compiler generates
     // relative calls and we need an absolute one
@@ -1142,7 +1143,7 @@
     ASM("call *%0" : : "r" (&setup));
 }
 
-void setup(char * bi) 
+void setup(char * bi)
 {
     if(!Traits<System>::multicore || (APIC::id() == 0)) {
         kerr  << endl;
Index: src/utility/ostream.cc
===================================================================
--- src/utility/ostream.cc	(revision 3782)
+++ src/utility/ostream.cc	(working copy)
@@ -47,7 +47,7 @@
     }
 
     return utoa(static_cast<unsigned int>(v), s, i);
-} 
+}
 
 
 int OStream::utoa(unsigned int v, char * s, unsigned int i)
@@ -84,7 +84,7 @@
     }
 
     return llutoa(static_cast<unsigned long long int>(v), s, i);
-} 
+}
 
 
 int OStream::llutoa(unsigned long long int v, char * s, unsigned int i)
@@ -123,6 +123,6 @@
             = _digits[v & 0xf];
 
     return j + 2;
-}    
+}
 
 __END_UTIL
