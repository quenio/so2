Index: include/system/config.h
===================================================================
--- include/system/config.h	(revision 3782)
+++ include/system/config.h	(working copy)
@@ -7,15 +7,15 @@
 // ARCHITECTURE, MACHINE, AND APPLICATION SELECTION
 // This section is generated automatically from makedefs by $EPOS/etc/makefile
 //============================================================================
-#define MODE xxx
-#define ARCH xxx
-#define MACH xxx
-#define MMOD xxx
-#define APPL xxx
-#define __mode_xxx__
-#define __arch_xxx__
-#define __mach_xxx__
-#define __mmod_xxx__
+#define MODE library
+#define ARCH ia32
+#define MACH pc
+#define MMOD legacy
+#define APPL philosophers_dinner
+#define __mode_library__
+#define __arch_ia32__
+#define __mach_pc__
+#define __mmod_legacy__
 
 #if defined (__arch_avr__) || defined (__mmod_lm3s811__)
 #define __no_networking__
Index: include/thread.h
===================================================================
--- include/thread.h	(revision 3782)
+++ include/thread.h	(working copy)
@@ -101,6 +101,8 @@
 
     Criterion & criterion() { return const_cast<Criterion &>(_link.rank()); }
 
+    // TODO Implementar lock()/unlock() usando Spin.
+    // TODO Depois da modificação, verificar usos de lock() / unlock() fora de Thread. Precisam de Spin?
     static void lock() { CPU::int_disable(); }
     static void unlock() { CPU::int_enable(); }
     static bool locked() { return CPU::int_disabled(); }
Index: include/utility/heap.h
===================================================================
--- include/utility/heap.h	(revision 3782)
+++ include/utility/heap.h	(working copy)
@@ -143,6 +143,7 @@
 
 private:
     void enter() {
+        // WARNING: Se houver algum deadlock, verificar se não é porque acquire() está antes de int_disable()
         _lock.acquire();
         CPU::int_disable();
     }
Index: src/init/init_first.cc
===================================================================
--- src/init/init_first.cc	(revision 3782)
+++ src/init/init_first.cc	(working copy)
@@ -38,7 +38,7 @@
             // Idle thread creation must succeed main, thus avoiding implicit rescheduling.
             new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
         } else
-            first = new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
+            first = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::IDLE), &Thread::idle);
 
         Machine::smp_barrier();
 
@@ -60,7 +60,7 @@
 };
 
 // Global object "init_first" must be constructed last in the context of the
-// OS, for it activates the first application thread (usually main()) 
+// OS, for it activates the first application thread (usually main())
 Init_First init_first;
 
 __END_SYS
Index: src/init/init_system.cc
===================================================================
--- src/init/init_system.cc	(revision 3782)
+++ src/init/init_system.cc	(working copy)
@@ -22,7 +22,7 @@
         // Only the boot CPU runs INIT_SYSTEM fully
         if(Machine::cpu_id() != 0) {
             // Wait until the boot CPU has initialized the machine
-            Machine::smp_barrier();
+            Machine::smp_barrier(); // WARNING: Se não estiver funcionando, verificar se ncpus está realmente inicializado.
             // For IA-32, timer is CPU-local. What about other SMPs?
             Timer::init();
             Machine::smp_barrier();
@@ -66,6 +66,8 @@
             db<Init>(INF) << "done!" << endl;
         }
 
+        Machine::smp_barrier();
+
         // Initialization continues at init_first
     }
 };
Index: src/setup/pc_setup.cc
===================================================================
--- src/setup/pc_setup.cc	(revision 3782)
+++ src/setup/pc_setup.cc	(working copy)
@@ -526,6 +526,7 @@
         kout << "  APP code:     " << si->lm.app_code_size << " bytes"
              << "\tdata: " << si->lm.app_data_size << " bytes" << endl;
     }
+    kout << "  CPU count:    " << si->bm.n_cpus << endl;
     if(si->lm.has_ext) {
         kout << "  Extras:       " << si->lm.app_extra_size << " bytes" << endl;
     }
