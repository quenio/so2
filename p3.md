### Tarefas
- [x] locking correto do SO:
  - [x] mutex - TODOs
  - [x] semaforo - TODOs
  - [x] alarme
  - [x] thread - TODOs
    - [x] lock()
    - [x] unlock()
  - [x] temporizador
  - [x] heap
- [x] Fazer TODOs  
- [x] Implementar round-robin com multi-head.
- [x] Implementar spin lock em Thread.
- [x] Implementar algoritmo para deixar threads ocupados.
- [x] Testando threads com 8 CPUs
- [x] Implementado o Philosopher's dinner com contagem de números pares/impares e impressão de cpu id.
- [x] Fazer diff das mudanças
- [x] Comparar com o código do EPOS
- [x] Revisar código do Scheduler_Timer
- [x] Scheduler.schedulables()
- [x] revisar código de termino de execução da maquina
- [x] Porque QueueWrapper precisa ser usada em sinchronizer?
- [x] fazer testes de alocacao na Heap
- [x] revisar TODOs restantes
- [ ] escrever relatorio
  - [x] RR & multi-head
  - [ ] spin lock em Thead::lock() and Thread::unlock()
  - [ ] correção em Thread::dispatch()
  - [ ] 8 CPUs & Philosopher's Dinner
  - [ ] Correção no heap
  - [ ] correção em queue
  - [ ] mudanças em init_first()
  - [ ] revisão do mutex, semaforo, etc.
- [ ] revisão final do enunciado do problema no Moodle
- [ ] Se der tempo
    - [ ] fazer slides
    - [ ] int_not?

## Multihead Queue & Round-Robin

A classe `Scheduling_Queue`, que é a classe base de `Scheduler`, agora herda da classe `Multihead_Scheduling_List`. Esta última permite `Scheduler` ter várias cabeças em sua fila. Com as modificações feitas na classe `Round-Robin`, cada cabeça corresponderá a uma CPU. Desta forma, `Scheduler` poderá distribuir a alocação de `threads` entre as CPUs disponíveis. Veja abaixo, a nova classe base de `Scheduling_Queue`:

```cpp
// Scheduling_Queue
template<typename T, typename R = typename T::Criterion>
class Scheduling_Queue: public Multihead_Scheduling_List<T> {};

// Scheduler
// Objects subject to scheduling by Scheduler must declare a type "Criterion"
// that will be used as the scheduling queue sorting criterion (viz, through
// operators <, >, and ==) and must also define a method "link" to export the
// list element pointing to the object being handled.
template<typename T>
class Scheduler: public Scheduling_Queue<T>
{
  ...
```

Para que `Scheduler` funcione com uma `Multihead_Scheduling_List`, foi preciso alterar a política round-robin para definir que o número de cabeças na lista corresponde ao número de CPUs e qual a cabeça da fila que corresponde a CPU em execução. Veja abaixo:

```cpp
// Round-Robin
class RR: public Priority
{
public:
    enum {
        MAIN   = 0,
        NORMAL = 1,
        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
    };

    static const bool timed = true;
    static const bool dynamic = false;
    static const bool preemptive = true;

    static const unsigned int HEADS = Traits<Build>::CPUS;

    static int current_head() { return Machine::cpu_id(); }

public:
    RR(int p = NORMAL): Priority(p) {}
};
```

Observe que `HEADS` acima é a constante que informa a `Scheduler` o número de cabeças necessárias (uma para cada CPU), enquanto `current_head()` vai informar qual é a cabeça para a CPU em execução.
