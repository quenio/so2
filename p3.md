### Tarefas
- [x] locking correto do SO:
  - [x] mutex - TODOs
  - [x] semaforo - TODOs
  - [x] alarme
  - [x] thread - TODOs
    - [x] lock()
    - [x] unlock()
  - [x] temporizador
  - [x] heap
- [x] Fazer TODOs  
- [x] Implementar round-robin com multi-head.
- [x] Implementar spin lock em Thread.
- [x] Implementar algoritmo para deixar threads ocupados.
- [x] Testando threads com 8 CPUs
- [x] Implementado o Philosopher's dinner com contagem de números pares/impares e impressão de cpu id.
- [x] Fazer diff das mudanças
- [x] Comparar com o código do EPOS
- [x] Revisar código do Scheduler_Timer
- [x] Scheduler.schedulables()
- [x] revisar código de termino de execução da maquina
- [x] Porque QueueWrapper precisa ser usada em sinchronizer?
- [x] fazer testes de alocacao na Heap
- [x] revisar TODOs restantes
- [ ] escrever relatorio
  - [x] RR & multi-head
  - [x] spin lock em Thead::lock() and Thread::unlock()
  - [ ] correção em Thread::dispatch()
  - [ ] 8 CPUs & Philosopher's Dinner
  - [ ] Correção no heap
  - [ ] correção em queue
  - [ ] mudanças em init_first()
  - [ ] revisão do mutex, semaforo, etc.
- [ ] revisão final do enunciado do problema no Moodle
- [ ] Se der tempo
    - [ ] fazer slides
    - [ ] int_not?

## Multihead Queue & Round-Robin

A classe `Scheduling_Queue`, que é a classe base de `Scheduler`, agora herda da classe `Multihead_Scheduling_List`. Esta última permite `Scheduler` ter várias cabeças em sua fila. Com as modificações feitas na classe `Round-Robin`, cada cabeça corresponderá a uma CPU. Desta forma, `Scheduler` poderá distribuir a alocação de `threads` entre as CPUs disponíveis. Veja abaixo, a nova classe base de `Scheduling_Queue`:

```cpp
// Scheduling_Queue
template<typename T, typename R = typename T::Criterion>
class Scheduling_Queue: public Multihead_Scheduling_List<T> {};

// Scheduler
// Objects subject to scheduling by Scheduler must declare a type "Criterion"
// that will be used as the scheduling queue sorting criterion (viz, through
// operators <, >, and ==) and must also define a method "link" to export the
// list element pointing to the object being handled.
template<typename T>
class Scheduler: public Scheduling_Queue<T>
{
  ...
```

Para que `Scheduler` funcione com uma `Multihead_Scheduling_List`, foi preciso alterar a política round-robin para definir que o número de cabeças na lista corresponde ao número de CPUs e qual a cabeça da fila que corresponde a CPU em execução. Veja abaixo:

```cpp
// Round-Robin
class RR: public Priority
{
public:
    enum {
        MAIN   = 0,
        NORMAL = 1,
        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
    };

    static const bool timed = true;
    static const bool dynamic = false;
    static const bool preemptive = true;

    static const unsigned int HEADS = Traits<Build>::CPUS;

    static int current_head() { return Machine::cpu_id(); }

public:
    RR(int p = NORMAL): Priority(p) {}
};
```

Observe que `HEADS` acima é a constante que informa a `Scheduler` o número de cabeças necessárias (uma para cada CPU), enquanto `current_head()` vai informar qual é a cabeça para a CPU em execução.

## Spin Lock & Escalonamento

Para que o escalonamento de `threads` funcione corretamente num ambiente multi-processado, foi preciso modificar o mecanismo de `locking` na classe `Thread`. Desabilitar as interrupções do processador corrente não é suficiente, pois as outras CPUs podem executar as seções críticas da classe `Thread`.

Para solucionar este problema, foi utilizado a classe `Spin`, que implementa um `spin lock` utilizando da primitiva de sincronização `cas` - `compare-and-swap`. Na arquitetura IA32, a primitiva `cas` é implementada pela instrução `lock cmpxchgl` atomicidade entre todas as CPUs do sistema.

Veja abaixo as alterações na classe `Thread` referente ao métodos `lock()` e `unlock()`:

```cpp
class Thread
{
   ...
   static void lock()
   {
     CPU::int_disable();
     spinLock();
   }

   static void unlock()
   {
     spinUnlock();
     CPU::int_enable();
   }
   ...
private:
   static void spinLock() { if (smp) _spinLock.acquire(); }
   static void spinUnlock() { if (smp) _spinLock.release(); }

 protected:
   static Spin _spinLock;
   ...
};
```

Além das alterações acima, também foi preciso modificar o método `Thread::dispatch()` para que este libere o `spin lock` antes de mudar de contexto:

```cpp
void Thread::dispatch(Thread * prev, Thread * next, bool charge)
{
    if(charge) {
        if(Criterion::timed)
            _timer->reset();
    }

    if(prev != next) {
        if(prev->_state == RUNNING)
            prev->_state = READY;
        next->_state = RUNNING;

        db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
        db<Thread>(INF) << "prev={" << prev << ",ctx=" << *prev->_context << "}" << endl;
        db<Thread>(INF) << "next={" << next << ",ctx=" << *next->_context << "}" << endl;

        spinUnlock();

        CPU::switch_context(&prev->_context, next->_context);
    } else {
      spinUnlock();
    }

    CPU::int_enable();
}
```

Sem as alterações acima, todas as CPUs ficariam bloqueadas pelo `spin lock` e nenhum `thread` poderia executar, ou seja, `thread starvation`.
