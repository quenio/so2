### Tarefas
- [x] locking correto do SO:
  - [x] mutex - TODOs
  - [x] semaforo - TODOs
  - [x] alarme
  - [x] thread - TODOs
    - [x] lock()
    - [x] unlock()
  - [x] temporizador
  - [x] heap
- [x] Fazer TODOs  
- [x] Implementar round-robin com multi-head.
- [x] Implementar spin lock em Thread.
- [x] Implementar algoritmo para deixar threads ocupados.
- [x] Testando threads com 8 CPUs
- [x] Implementado o Philosopher's dinner com contagem de números pares/impares e impressão de cpu id.
- [x] Fazer diff das mudanças
- [x] Comparar com o código do EPOS
- [x] Revisar código do Scheduler_Timer
- [x] Scheduler.schedulables()
- [x] revisar código de termino de execução da maquina
- [x] Porque QueueWrapper precisa ser usada em sinchronizer?
- [x] fazer testes de alocacao na Heap
- [x] revisar TODOs restantes
- [ ] escrever relatorio
  - [x] RR & multi-head
  - [x] spin lock em Thead::lock() and Thread::unlock()
  - [x] correção em Thread::dispatch()
  - [x] Correção no heap
  - [x] mudanças em init_first()
  - [x] mudanças em init_system()
  - [ ] revisão do mutex, semaforo, etc.
  - [ ] 8 CPUs & Philosopher's Dinner
  - [ ] correção em queue
- [ ] revisão final do enunciado do problema no Moodle
- [ ] Se der tempo
    - [ ] fazer slides
    - [ ] int_not?

## Multihead Queue & Round-Robin

A classe `Scheduling_Queue`, que é a classe base de `Scheduler`, agora herda da classe `Multihead_Scheduling_List`. Esta última permite `Scheduler` ter várias cabeças em sua fila. Com as modificações feitas na classe `Round-Robin`, cada cabeça corresponderá a uma CPU. Desta forma, `Scheduler` poderá distribuir a alocação de `threads` entre as CPUs disponíveis. Veja abaixo, a nova classe base de `Scheduling_Queue`:

```cpp
// Scheduling_Queue
template<typename T, typename R = typename T::Criterion>
class Scheduling_Queue: public Multihead_Scheduling_List<T> {};

// Scheduler
// Objects subject to scheduling by Scheduler must declare a type "Criterion"
// that will be used as the scheduling queue sorting criterion (viz, through
// operators <, >, and ==) and must also define a method "link" to export the
// list element pointing to the object being handled.
template<typename T>
class Scheduler: public Scheduling_Queue<T>
{
  ...
```

Para que `Scheduler` funcione com uma `Multihead_Scheduling_List`, foi preciso alterar a política round-robin para definir que o número de cabeças na lista corresponde ao número de CPUs e qual a cabeça da fila que corresponde a CPU em execução. Veja abaixo:

```cpp
// Round-Robin
class RR: public Priority
{
public:
    enum {
        MAIN   = 0,
        NORMAL = 1,
        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
    };

    static const bool timed = true;
    static const bool dynamic = false;
    static const bool preemptive = true;

    static const unsigned int HEADS = Traits<Build>::CPUS;

    static int current_head() { return Machine::cpu_id(); }

public:
    RR(int p = NORMAL): Priority(p) {}
};
```

Observe que `HEADS` acima é a constante que informa a `Scheduler` o número de cabeças necessárias (uma para cada CPU), enquanto `current_head()` vai informar qual é a cabeça para a CPU em execução.

## Spin Lock & Escalonamento

Para que o escalonamento de `threads` funcione corretamente num ambiente multi-processado, foi preciso modificar o mecanismo de `locking` na classe `Thread`. Desabilitar as interrupções do processador corrente não é suficiente, pois as outras CPUs podem executar as seções críticas da classe `Thread`.

Para solucionar este problema, foi utilizado a classe `Spin`, que implementa um `spin lock` utilizando da primitiva de sincronização `cas` - `compare-and-swap`. Na arquitetura IA32, a primitiva `cas` é implementada pela instrução `lock cmpxchgl` atomicidade entre todas as CPUs do sistema.

Veja abaixo as alterações na classe `Thread` referente ao métodos `lock()` e `unlock()`:

```cpp
class Thread
{
   ...
   static void lock()
   {
     CPU::int_disable();
     spinLock();
   }

   static void unlock()
   {
     spinUnlock();
     CPU::int_enable();
   }
   ...
private:
   static void spinLock() { if (smp) _spinLock.acquire(); }
   static void spinUnlock() { if (smp) _spinLock.release(); }

 protected:
   static Spin _spinLock;
   ...
};
```

Além das alterações acima, também foi preciso modificar o método `Thread::dispatch()` para que este libere o `spin lock` antes de mudar de contexto:

```cpp
void Thread::dispatch(Thread * prev, Thread * next, bool charge)
{
    if(charge) {
        if(Criterion::timed)
            _timer->reset();
    }

    if(prev != next) {
        if(prev->_state == RUNNING)
            prev->_state = READY;
        next->_state = RUNNING;

        spinUnlock();

        CPU::switch_context(&prev->_context, next->_context);
    } else {
      spinUnlock();
    }

    CPU::int_enable();
}
```

Sem as alterações acima, todas as CPUs ficariam bloqueadas pelo `spin lock` e nenhum `thread` poderia executar, ou seja, `thread starvation`.

## Correção em `Heap`

No método `enter()` da classe `Heap_Wrapper`, moveu-se a desabilitação das interrupções para antes de adquirir o `spin lock`. Isto evita que haja uma troca de contexto para outro `thread` sem a liberação da `spin lock`, o que poderia bloquear todas CPUs que estejam alocando memória na `heap`. Veja abaixo:

```cpp
class Heap_Wrapper ...
{
  ...
  void enter() {
      CPU::int_disable();
      _lock.acquire();
  }
  ...
}
```

## Correção em `init_first.cc`

Em `init_first`, quando criando os `idle threads` das APs, marcando o `idle thread` como `RUNNING`, visto que inicialmente seu contexto será carregado em `init_first`, ao invés de ser escalonado:

```cpp
if(Machine::cpu_id() == 0) {
    first = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(__epos_app_entry));

    // Idle thread creation must succeed main, thus avoiding implicit rescheduling.
    new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
} else
    first = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::IDLE), &Thread::idle);
```

## Correção em `init_system.cc`

Foi feita a equalização das barreiras em `init_system.cc` entre a BSP e as APs para garantir que todas as CPUs:


```cpp
--- src/init/init_system.cc	(revision 3782)
+++ src/init/init_system.cc	(working copy)
         // Only the boot CPU runs INIT_SYSTEM fully
         if(Machine::cpu_id() != 0) {
             // Wait until the boot CPU has initialized the machine
             Machine::smp_barrier();
             // For IA-32, timer is CPU-local. What about other SMPs?
             Timer::init();
             Machine::smp_barrier();
@@ -66,6 +66,8 @@
             db<Init>(INF) << "done!" << endl;
         }

+        Machine::smp_barrier();
+
         // Initialization continues at init_first
     }
 };
```

## Verificação dos mecanismos de `locking` do EPOS

Foi feita uma verificação dos mecanismos de `locking` de todo a sistema para guarantir seu funcionamento num ambiente multi-processado. Veja a seguir nas sub-seções abaixo.

### 'Mutex`

O método `lock()` de `Mutex` utiliza a primitiva atomica `tsl` - `test-and-set` - que vai retornar o valor atual de `_lock` e depois marcá-lo. Na arquitetura IA32, `tsl` é implementada pela instrução que garante atomicidade e coerência de cache entre todas as CPUs do sistema. Veja baixo:

```
void Mutex::lock()
{
    db<Synchronizer>(TRC) << "Mutex::lock(this=" << this << ")" << endl;

    begin_atomic();
    if(tsl(_locked))
        sleep(); // implicit end_atomic()
    else
        end_atomic();
}

void Mutex::unlock()
{
    db<Synchronizer>(TRC) << "Mutex::unlock(this=" << this << ")" << endl;

    begin_atomic();
    if(_queue.empty()) {
        _locked = false;
        end_atomic();
    } else
        wakeup(); // implicit end_atomic()
}
```  

Além disso, `begin_atomic()` e `end_atomic()`, implementados respectivamente por `Thread::lock()` e `Thread::unlock()` em `synchronizer.h`, protegem a execução de `sleep()` e `wakep()`, e do acesso a _queue de espera.

### `Semaphore`

Da mesma forma que no caso do `Mutex`, `Semaphore` utiliza `begin_atomic()` e `end_atomic()` para proteger seus métodos `p()` e `v()`.

Para incrementar seu contador, `Semaphore` utiliza as primitivas atômicas `finc()` e `fdec()` que garantem a coerência de cache entre todas as CPUs, pois utilizam respectivamente a instrução `lock xadd` da arquitetura IA32.

Veja a seguir de `p()` e `v()`:

```cpp
void Semaphore::p()
{
    db<Synchronizer>(TRC) << "Semaphore::p(this=" << this << ",value=" << _value << ")" << endl;

    begin_atomic();
    if(fdec(_value) < 1)
        sleep(); // implicit end_atomic()
    else
        end_atomic();
}


void Semaphore::v()
{
    db<Synchronizer>(TRC) << "Semaphore::v(this=" << this << ",value=" << _value << ")" << endl;

    begin_atomic();
    if(finc(_value) < 0)
        wakeup();  // implicit end_atomic()
    else
        end_atomic();
}
```


- [x] alarme
